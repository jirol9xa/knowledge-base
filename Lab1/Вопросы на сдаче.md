### Что такое option rom и зачем он нужен? В чем его отличие от legacy bios и uefi option roms? Как можно защищаться от вредоносных option roms? 

Option Rom (Дополнительное ПЗУ) - это часть прошивки, которая находится в BIOS и запускается для инициализации устройства и его регистрации в BIOS. По сути, это драйвер, который взаимодействует между службами BIOS и устройствами.

[Про байткод на UEFI](https://uefi.org/sites/default/files/resources/Phoenix_UEFI_Plugfest2010_Taipei_final_1012.pdf):
EBC (EFI Byte Code) allows a single image option ROM to operate on multiple CPU environments.
Из-за этого нет необходимости дублировать код ради совместимости с несколькими процессорами. 

[Про безопасность](https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/uefi-validation-option-rom-validation-guidance?view=windows-10#1-uefi-and-option-roms):
Идет проверка, что все сторонние приложения в том числе и код с option ROMs подписан, если нашлось что-то не подписанное, то такой код исполняться не должен. После всех проверок на подписи начинается поиск в базе данных доверенного ПО тех подписей, которые были получены на прошлом шаге. Если приложение внесено в черный список или не было найдено в доверенной базе данных, то его код  не будет исполнятся и будет создана запись в  Image Execution Information Table.  

[Про совместимость](https://logi.wiki/index.php/Option_ROM):
UEFI может использовать legacy option ROMs, когда включен режим совместимости ( Compatibility Support Module(CSM)). Однако для этого требуется этап аутентификации, которая является местом потенциальной угрозы, поэтому переход в CSM режим и запуск legacy option ROMs запрещены. 
### Безопасные интерфейсы из annex стандарта ISO C.
fopen_s, fprintf_s, printf_s ... : Просто выполняют run-time проверки на нулевые указатели.

fsanf_s: При обработке флага %s принимает пару аргументов char *  и size_t. Вторая переменная указывает, сколько памяти есть для записи в первый аргумент.

gets_s: Выполняет run-time проверку на nullptr и принимает вторым аргументов число символов, которые надо считать. 

Семейство handler'ов для обработки нештатных случаев

memcpy_s: Проверка на nullptr, проверка на overlap, проверка на максимальный размер блока для копирования.

memmove: Выполняет проверку на overlap

memmove_s:  Выполняет проверку на nullptr
### Какие существуют виды регистров процессора? Для чего нужен каждый вид? Что такое return oriented programming и какие регистры при этом используются? 


По назначению регистры процессора различаются на:

- аккумулятор (RAX) — используется для хранения промежуточных результатов арифметических и логических операций и инструкций ввода-вывода;
- флаговые — хранят признаки результатов арифметических и логических операций;
- общего назначения — хранят операнды арифметических и логических выражений, индексы и адреса;
- индексные — хранят индексы исходных и целевых элементов массива;
- указательные — хранят указатели на специальные области памяти (указатель текущей операции, указатель базы, указатель стека);
- сегментные — хранят адреса и селекторы сегментов памяти;
- управляющие (RIP) — хранят информацию, управляющую состоянием процессора, а также адреса системных таблиц.
- векторные -- задействованы в SIMD инструкциях 
- floating-point

Сегментные регистры могут использоваться и для других целей. По типу указателя на таблицу для thread local storage переменных.  

Также регистры можно разделить относительно calling convention:
-  Caller-save (Scratch registers)
- Callee save

Основная идея тут в том, чтобы не потерять результат промежуточных вычислений, если происходит call. В то же время вызываемой функции не придется сохранять никакие регистры, если она может обойтись в своих вычислениях только caller-save. 